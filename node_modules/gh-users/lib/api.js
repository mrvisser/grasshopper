/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');

var AuthUtil = require('gh-auth/lib/util');
var AppsAPI = require('gh-apps');
var DB = require('gh-core/lib/db');
var GrasshopperUtil = require('gh-core/lib/util');
var log = require('gh-core/lib/logger').logger('gh-users');
var OrgUnitDAO = require('gh-orgunit/lib/internal/dao');
var Validator = require('gh-core/lib/validator').Validator;

var UsersAuthz = require('./authz');
var UsersDAO = require('./internal/dao');

/**
 * Get a user
 *
 * @param  {Number}         id                              The id of the user to retrieve
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error object, if any
 * @param  {User}           callback.user                   The requested user
 */
var getUser = module.exports.getUser = function(id, callback) {
    // TODO: id validation

    UsersDAO.getUser(id, callback);
};

/**
 * Get a user by its authentication credentials
 *
 * @param  {Number}         appId                           The id of the app to which the user belongs
 * @param  {String}         strategy                        The authentication strategy for the user. One of `local` or `shibboleth`
 * @param  {String}         identifier                      The unique credentials identifier for the user. `email` when using local authentication or `shibbolethId` when using Shibboleth authentication
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error object, if any
 * @param  {User}           callback.user                   The requested user
 */
var getUserByCredentials = module.exports.getUserByCredentials = function(appId, strategy, identifier, callback) {
    // TODO: validate strategy
    // TODO: validate app
    // TODO: validate identifier

    UsersDAO.getUserByCredentials(appId, strategy, identifier, callback);
};

/**
 * Create a new user
 *
 * @param  {Context}        ctx                             The current execution context containing the user and application
 * @param  {Number}         appId                           The id of the app on which the user should be created
 * @param  {Object}         userProfile                     The user profile parameters for the user
 * @param  {String}         userProfile.displayName         The name of the user
 * @param  {String}         userProfile.email               The email address for the user
 * @param  {String}         userProfile.emailPreference     The email preference for the user. One of `immediate` or `no`
 * @param  {String}         userProfile.isAdmin             Whether the user is an app administrator. Only allowed when the current user is an administrator
 * @param  {Object}         credentials                     The authentication credentials for the user
 * @param  {String}         credentials.strategy            The authentication strategy for the user. One of `local` or `shibboleth`
 * @param  {String}         [credentials.password]          The password with which the user will authenticate. Only required when using the local authentiation strategy
 * @param  {String}         [credentials.shibbolethId]      The unique shibboleth id for the user. Only required when using the Shibboleth authentication strategy
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {User}           callback.user                   The created user
 */
var createUser = module.exports.createUser = function(ctx, appId, userProfile, credentials, callback) {
    userProfile = userProfile || {};
    userProfile.emailPreference = userProfile.emailPreference || 'immediate';
    userProfile.isAdmin = GrasshopperUtil.getBooleanParam(userProfile.isAdmin, false);

    // TODO: displayName validation
    // TODO: email validation
    // TODO: email preference validation
    // TODO: isAdmin validation
    // TODO: strategy validation
    // TODO: validate password when using local
    // TODO: validate shibbolethid when using shib

    // Verify that the provided app exists
    AppsAPI.getApp(ctx, appId, function(err, app) {
        if (err) {
            return callback(err);
        }

        // Ensure that a user with the provided credentials doesn't already exist
        getUserByCredentials(appId, credentials.strategy, (credentials.shibbolethId || userProfile.email), function(err, user) {
            if (user) {
                log().error({'err': err, 'credentials': (credentials.shibbolethId || userProfile.email)}, 'Failed to create a new user');
                return callback({'code': 400, 'msg': 'A user with the provided authentication credentials already exists'});
            } else if (err && err.code !== 404) {
                return callback(err);
            }

            UsersDAO.createUser(appId, userProfile, credentials, callback);
        });
    });
};

/**
 * Validate the login credentials for a user
 *
 * @param  {Number}         appId                           The id of the app to which the user belongs
 * @param  {String}         email                           The email of the user to attempt login validation for. The email acts as the username
 * @param  {String}         password                        The password to attempt login validation with
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error object, if any
 * @param  {User}           callback.user                   The user for the provided username and password. If the provided password was incorrect, this will be `null`
 */
var validateLoginCredentials = module.exports.validateLoginCredentials = function(appId, email, password, callback) {
    // TODO: email validation
    // TODO: password validation

    // Ensure that a user with the provided credentials exist
    getUserByCredentials(appId, 'local', email, function(err, user) {
        // No user could be found for the provided credentials
        if (err && err.code === 404) {
            log().warn({'err': err, 'email': email}, 'The provided user email is incorrect');
            return callback({'code': 401, 'msg': 'The provided user email is incorrect'});
        // A different error occured
        } else if (err) {
            log().error({'err': err, 'email': email}, 'Failed to validate the login credentials for a user');
            return callback(err);
        }

        var match = AuthUtil.comparePassword(password, user.password);
        if (!match) {
            log().warn({'err': err, 'email': email}, 'The provided user password is incorrect');
            return callback({'code': 401, 'msg': 'The provided user password is incorrect'});
        }

        return callback(null, user);
    });
};


//////////////
// Calendar //
//////////////


/**
 * Get the calendar for a user
 *
 * @param  {Context}    ctx                 The current execution context containing the user and application
 * @param  {Number}     id                  The id of the user to get the calendar for
 * @param  {String}     start               The timestamp (ISO 8601) from which to get the calendar for the user
 * @param  {String}     end                 The timestamp (ISO 8601) until which to get the calendar for the user
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {Event[]}    callback.events     The events in a user's calendar
 */
var getUserCalendar = module.exports.getUserCalendar = function(ctx, id, start, end, callback) {
    // Ensure that the user id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can retrieve a user\'s calendar'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    validator.check(start, {'code': 400, 'msg': 'A start time must be provided in a valid date format'}).isDate();
    validator.check(end, {'code': 400, 'msg': 'An end time must be provided in a valid date format'}).isDate();
    validator.check(start, {'code': 400, 'msg': 'The start time must be before the end time'}).isBefore(end);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the user exists
    getUser(id, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can get the calendar
        UsersAuthz.canGetUserCalendar(ctx, user, function(err, canGetCalendar) {
            if (err) {
                return callback(err);
            } else if (!canGetCalendar) {
                log().warn({'id': id, 'actor': ctx.user.id}, 'Unauthorized attempt at retrieving a user\'s calendar');
                return callback({'code': 401, 'msg': 'You are not allowed to retrieve this user\'s calendar'});
            }

            // Get the events in the user calendar
            UsersDAO.getUserCalendar(user, start, end, function(err, events) {
                if (err) {
                    return callback(err);
                }

                // Retrieve the organisational units through which the events were added
                // to the calendar (if any)
                var orgUnitIds = _.chain(events)
                    .pluck('context')
                    .uniq(orgUnitIds)
                    .compact()
                    .value();

                OrgUnitDAO.getOrgUnitsById(orgUnitIds, function(err, orgUnits) {
                    if (err) {
                        return callback(err);
                    }

                    orgUnits = _.indexBy(orgUnits, 'id');

                    // Add the context on each event
                    events = _.map(events, function(event) {
                        // We can't simply do `event.context = orgUnit;` as that information
                        // would get lost when sequelize serializes the event to JSON
                        var serializedEvent = event.toJSON();
                        serializedEvent.context = orgUnits[event.context];
                        return serializedEvent;
                    });

                    return callback(null, events);
                });
            });
        });
    });
};
