/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');

var CalendarInfo = require('gh-calendar/lib/model').CalendarInfo;
var CalendarUtil = require('gh-calendar/lib/util');
var EventsDAO = require('gh-events/lib/internal/dao');
var GrasshopperUtil = require('gh-core/lib/util');
var GroupsAPI = require('gh-groups');
var GroupsDAO = require('gh-groups/lib/internal/dao');
var log = require('gh-core/lib/logger').logger('gh-series');
var OrgUnitDAO = require('gh-orgunit/lib/internal/dao');
var UsersAPI = require('gh-users');
var UsersDAO = require('gh-users/lib/internal/dao');
var Validator = require('gh-core/lib/validator').Validator;

var SeriesAuthz = require('./authz');
var SeriesDAO = require('./internal/dao');


//////////
// CRUD //
//////////

/**
 * Create a serie
 *
 * @param  {Context}        ctx                         Standard context containing the current user and the current app
 * @param  {Number}         appId                       The id of the application that this serie will belong to
 * @param  {String}         displayName                 The name of the serie
 * @param  {String}         [description]               The description of the serie
 * @param  {Number}         [groupId]                   The id of the group that can manage the event. Defaults to creating a new group with the current user as a member
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error object, if any
 * @param  {Serie}          callback.serie              The created serie
 */
var createSerie = module.exports.createSerie = function(ctx, appId, displayName, description, groupId, callback) {
    // Ensure that the app id is a valid number
    appId = GrasshopperUtil.getNumberParam(appId);

    // Ensure that the group id (if any) is a valid number
    groupId = GrasshopperUtil.getNumberParam(groupId);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can create series'}).isLoggedInUser(ctx);
    validator.check(displayName, {'code': 400, 'msg': 'A valid displayName must be provided'}).isShortString();
    validator.check(appId, {'code': 400, 'msg': 'A valid application id must be provided'}).isInt();
    if (description) {
        validator.check(description, {'code': 400, 'msg': 'A description can be at most 1000 characters long'}).isMediumString();
    }
    if (groupId) {
        validator.check(groupId, {'code': 400, 'msg': 'A valid group id must be provided'}).isInt();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure that the user can create a serie on the specified application
    if (appId !== ctx.app.id && !ctx.user.isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'This serie cannot be created on this application'});
    }

    SeriesAuthz.canCreateSeries(ctx, function(err, canCreate) {
        if (err) {
            return callback(err);
        } else if (!canCreate) {
            log().warn({'id': serie.id}, 'Unauthorized attempt at creating a serie');
            return callback({'code': 401, 'msg': 'You are not allowed to create a serie'});
        }

        // If a group was specified, ensure it exists. Create
        // a group if none was specified
        GroupsAPI.getOrCreateGroup(ctx, appId, groupId, function(err, group) {
            if (err) {
                return callback(err);
            }

            SeriesDAO.createSerie(appId, displayName, description, group.id, callback);
        });
    });
};

/**
 * Update a serie
 *
 * @param  {Context}        ctx                         Standard context containing the current user and the current app
 * @param  {Number}         id                          The id of the serie to update
 * @param  {Object}         update                      The updates to persist. At least one field should be specified
 * @param  {String}         [update.displayName]        Updated event series name
 * @param  {String}         [update.description]        Updated event series description
 * @param  {Number}         [update.group]              Updated id of the group that can manage the event series
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error object, if any
 * @param  {Serie}          callback.serie              The updated serie
 */
var updateSerie = module.exports.updateSerie = function(ctx, id, update, callback) {
    update = update || {};

    // Ensure that the serie id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can update series'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    var updatedFields = _.keys(update);
    validator.check(updatedFields.length, {'code': 400, 'msg': 'At least 1 update value must be provided'}).min(1);
    _.each(updatedFields, function(updatedField) {
        validator.check(updatedField, {'code': 400, 'msg': 'Only displayName, description or group can be updated'}).isIn(['displayName', 'description', 'group']);
    });
    if (update.displayName) {
        validator.check(update.displayName, {'code': 400, 'msg': 'A displayName can be at most 256 characters long'}).isShortString();
    }
    if (update.group) {
        // Ensure that the group id (if any) is a valid number
        validator.check(update.group, {'code': 400, 'msg': 'A group must be provided'}).isInt();
        update.GroupId = GrasshopperUtil.getNumberParam(update.group);
        delete update.group;
    }
    if (update.description) {
        validator.check(update.description, {'code': 400, 'msg': 'A description can be at most 1000 characters long'}).isMediumString();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the serie exists
    getSerie(ctx, id, function(err, serie) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can update the serie
        SeriesAuthz.canUpdateSerie(ctx, serie, function(err, canUpdate) {
            if (err) {
                return callback(err);
            } else if (!canUpdate) {
                log().warn({'id': serie.id, 'actor': ctx.user.id}, 'Unauthorized attempt at updating a serie');
                return callback({'code': 401, 'msg': 'You are not allowed to update the serie'});
            }

            // Ensure the group exists, if any
            _validateOptionalGroup(ctx, update.GroupId, serie.AppId, function(err, group) {
                if (err) {
                    return callback(err);
                }

                // Update the serie
                SeriesDAO.updateSerie(serie, update, callback);
            });
        });
    });
};

/**
 * Get a serie
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Serie}          callback.serie      The retrieved serie
 */
var getSerie = module.exports.getSerie = function(ctx, id, callback) {
    // Ensure that the serie id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    SeriesDAO.getSerie(id, function(err, serie) {
        if (err) {
            return callback(err);
        }

        // Ensure that the serie is either being requested from the app it belongs to
        // or from an authenticated user on the global admin
        if (serie.AppId !== ctx.app.id && (!ctx.user || !ctx.user.isGlobalAdmin())) {
            return callback({'code': 401, 'msg': 'This serie cannot be retrieved on this application'});
        }

        return callback(null, serie);
    });
};

/**
 * Delete a serie
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to delete
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var deleteSerie = module.exports.deleteSerie = function(ctx, id, callback) {
    // Ensure that the serie id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can delete series'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getSerie(ctx, id, function(err, serie) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can delete the serie
        SeriesAuthz.canDeleteSerie(ctx, serie, function(err, canDelete) {
            if (err) {
                return callback(err);
            } else if (!canDelete) {
                log().warn({'id': serie.id, 'actor': ctx.user.id}, 'Unauthorized attempt at deleting a serie');
                return callback({'code': 401, 'msg': 'You are not allowed to delete the serie'});
            }

            SeriesDAO.deleteSerie(serie, callback);
        });
    });
};

/**
 * Ensure that a group, if any, exists and belongs to the given application
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         [groupId]           The id of the group to retrieve
 * @param  {Number}         appId               The id of the application that the group should belong to
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Group}          callback.group      The retrieved group or null, if no `groupId` was specified
 */
var _validateOptionalGroup = function(ctx, groupId, appId, callback) {
    if (!groupId) {
        return callback();
    }

    GroupsDAO.getGroup(groupId, function(err, group) {
        if (err) {
            return callback(err);
        } else if (group.AppId !== appId) {
            return callback({'code': 401, 'msg': 'The specified group does not belong to the same application as the serie'});
        }

        return callback(null, group);
    });
};

//////////////////
// Serie events //
//////////////////

/**
 * Add a set of events to a serie
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to add the events to
 * @param  {Number[]}       events              The id(s) of the event(s) to add to the serie
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var addSeriesEvents = module.exports.addSeriesEvents = function(ctx, id, events, callback) {
    // Ensure that the serie id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can add events to series'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    validator.check(null, {'code': 400, 'msg': 'The events should be specified as an array of ids'}).isArray(events);
    if (events) {
        validator.check(events.length, {'code': 400, 'msg': 'At least 1 event should be provided'}).min(1);
        _.each(events, function(event) {
            validator.check(event, {'code': 400, 'msg': 'A valid event id must be provided'}).isInt();
        });
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    events = _.chain(events)
        // Ensure we don't try to add an event twice
        .uniq()

        // Cast each event id to a proper number
        .map(function(val, index, array) {
            return GrasshopperUtil.getNumberParam(val);
        })
        .value();

    // Ensure the serie exists
    getSerie(ctx, id, function(err, serie) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can add events to the serie
        SeriesAuthz.canAddSeriesEvents(ctx, serie, function(err, canAdd) {
            if (err) {
                return callback(err);
            } else if (!canAdd) {
                log().warn({'id': serie.id, 'events': events}, 'Unauthorized attempt at adding events to a serie');
                return callback({'code': 401, 'msg': 'You are not allowed to add events to the serie'});
            }

            // Ensure the events exist
            EventsDAO.getEvents(events, function(err, events) {
                if (err) {
                    return callback(err);
                }

                // Ensure that the events being added to the serie belong to the same application
                var otherAppEvents = _.filter(events, function(event) {
                    return (event.AppId !== serie.AppId);
                });
                if (!_.isEmpty(otherAppEvents)) {
                    return callback({'code': 400, 'msg': 'Some of the provided events belong to another application'});
                }

                // Ensure we don't try to add an event that's already part of this serie
                SeriesDAO.getSeriesEvents(serie, null, null, 10000, 0, true, function(err, existingEvents) {
                    if (err) {
                        return callback(err);
                    }

                    // Get all the events that are NOT part of the series yet
                    var newEvents = _.filter(events, function(event) {
                        return !_.findWhere(existingEvents, {'id': event.id});
                    });

                    // If there are no new events, we can return early
                    if (_.isEmpty(newEvents)) {
                        return callback();
                    }

                    // Add the events to the serie
                    SeriesDAO.addSeriesEvents(serie, events, callback);
                });
            });
        });
    });
};

/**
 * Remove one or more events from a serie
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to remove the events from
 * @param  {Number[]}       events              The id(s) of the event(s) to remove form the serie
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var deleteSeriesEvents = module.exports.deleteSeriesEvents = function(ctx, id, events, callback) {
    // Ensure that the serie id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can remove events from series'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    validator.check(null, {'code': 400, 'msg': 'The events should be specified as an array of ids'}).isArray(events);
    if (events) {
        validator.check(events.length, {'code': 400, 'msg': 'At least 1 event should be provided'}).min(1);
        _.each(events, function(event) {
            validator.check(event, {'code': 400, 'msg': 'A valid event id must be provided'}).isInt();
        });
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    events = _.chain(events)
        // Ensure we don't try to add an event twice
        .uniq()

        // Cast each event id to a proper number
        .map(function(val, index, array) {
            return GrasshopperUtil.getNumberParam(val);
        })
        .value();

    // Ensure the serie exists
    getSerie(ctx, id, function(err, serie) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user is allowed to delete events from the serie
        SeriesAuthz.canDeleteSeriesEvents(ctx, serie, function(err, canDelete) {
            if (err) {
                return callback(err);
            } else if (!canDelete) {
                log().warn({'id': id, 'actor': ctx.user.id}, 'Unauthorized attempt at deleting events from a serie');
                return callback({'code': 401, 'msg': 'You are not allowed to delete events from this serie'});
            }

            // Ensure that we're removing events from a serie that are under a serie
            SeriesDAO.getSeriesEvents(serie, null, null, 10000, 0, true, function(err, existingEvents) {
                if (err) {
                    return callback(err);
                }

                // Get the event objects that should be removed from the serie
                var eventsToRemove = _.filter(existingEvents, function(existingEvent) {
                    return _.contains(events, existingEvent.id);
                });

                // Pass a message back to the caller if the events that are being removed
                // do not belong to this serie
                if (eventsToRemove.length !== events.length) {
                    return callback({'code': 400, 'msg': 'The provided events do not belong to this serie'});
                }

                // Remove the events from the serie
                SeriesDAO.deleteSeriesEvents(serie, eventsToRemove, callback);
            });
        });
    });
};


/**
 * Get the events for a serie
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to retrieve the events for
 * @param  {Number}         [limit]             The number of events that should be retrieved. Defaults to 10
 * @param  {Number}         [offset]            The number to start paging from. Defaults to 0
 * @param  {Boolean}        [upcoming]          Whether to only include upcoming events. Defaults to `true`
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Serie}          callback.serie      The serie the events belong to
 * @param  {Event[]}        callback.events     The events for a series
 */
var getSeriesEvents = module.exports.getSeriesEvents = function(ctx, id, limit, offset, upcoming, callback) {
    // Ensure that the paging values are valid
    limit = GrasshopperUtil.getNumberParam(limit, 10, 1, 25);
    offset = GrasshopperUtil.getNumberParam(offset, 0, 0);

    // Ensure that the serie id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    // Ensure that the upcoming flag is a boolean value
    upcoming = GrasshopperUtil.getBooleanParam(upcoming);

    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    return _getSeriesEvents(ctx, id, null, null, limit, offset, upcoming, callback);
};


///////////////
// Calendars //
///////////////

/**
 * Get the JSON calendar for a serie
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to retrieve the calendar for
 * @param  {String}         start               The timestamp (ISO 8601) from which to get the calendar for the event series
 * @param  {String}         end                 The timestamp (ISO 8601) until which to get the calendar for the event series
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Serie}          callback.serie      The serie the events belong to
 * @param  {Event[]}        callback.events     The calendar for a serie
 */
var getSeriesCalendar = module.exports.getSeriesCalendar = function(ctx, id, start, end, callback) {
    // Ensure that the serie id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    validator.check(start, {'code': 400, 'msg': 'A valid start date must be ISO8601 formatted'}).isDate();
    validator.check(end, {'code': 400, 'msg': 'A valid end date must be ISO8601 formatted'}).isDate();
    validator.check(start, {'code': 400, 'msg': 'The start time must be before the end time'}).isBefore(end);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getSeriesEvents(ctx, id, start, end, -1, 0, true, callback);
};

/**
 * Get the iCal calendar for a serie
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to retrieve the calendar for
 * @param  {String}         [start]             The timestamp (ISO 8601) from which to get the calendar for the event series
 * @param  {String}         [end]               The timestamp (ISO 8601) until which to get the calendar for the event series
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {String}         callback.events     The iCal calendar for a serie
 */
var getSeriesCalendarAsICal = module.exports.getSeriesCalendarAsICal = function(ctx, id, start, end, callback) {
    // Ensure that the serie id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    if (start) {
        validator.check(start, {'code': 400, 'msg': 'A valid start date must be ISO8601 formatted'}).isDate();
    }
    if (end) {
        validator.check(end, {'code': 400, 'msg': 'A valid end date must be ISO8601 formatted'}).isDate();
    }
    if (start && end) {
        validator.check(start, {'code': 400, 'msg': 'The start time must be before the end time'}).isBefore(end);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getSeriesEvents(ctx, id, start, end, -1, 0, true, function(err, serie, events) {
        if (err) {
            return callback(err);
        }

        // Convert the events to iCal
        var calendarInfo = _getCalendarInfo(ctx, serie, events);
        var iCal = CalendarUtil.eventsToICal(calendarInfo, events);
        return callback(null, iCal);
    });
};

/**
 * Get the RSS calendar for a serie
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to retrieve the calendar for
 * @param  {String}         [start]             The timestamp (ISO 8601) from which to get the calendar for the event series
 * @param  {String}         [end]               The timestamp (ISO 8601) until which to get the calendar for the event series
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {String}         callback.events     The RSS calendar for a serie
 */
var getSeriesCalendarAsRSS = module.exports.getSeriesCalendarAsRSS = function(ctx, id, start, end, callback) {
    // Ensure that the serie id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    if (start) {
        validator.check(start, {'code': 400, 'msg': 'A valid start date must be ISO8601 formatted'}).isDate();
    }
    if (end) {
        validator.check(end, {'code': 400, 'msg': 'A valid end date must be ISO8601 formatted'}).isDate();
    }
    if (start && end) {
        validator.check(start, {'code': 400, 'msg': 'The start time must be before the end time'}).isBefore(end);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getSeriesEvents(ctx, id, start, end, -1, 0, true, function(err, serie, events) {
        if (err) {
            return callback(err);
        }

        // Convert the events to RSS
        var calendarInfo = _getCalendarInfo(ctx, serie, events);
        var rss = CalendarUtil.eventsToRSS(calendarInfo, events);
        return callback(null, rss);
    });
};

/**
 * Get the calendar info for a serie
 *
 * @param  {Context}    ctx         Standard context containing the current user and the current app
 * @param  {Serie}      serie       The serie for which to get the calendar info
 * @param  {Event[]}    events      The events that are in the serie
 * @return {CalendarInfo}           An object representing the calendar info for the serie
 * @api private
 */
var _getCalendarInfo = function(ctx, serie, events) {
    var link = 'https://' + ctx.app.host + '/series/' + serie.id;
    return new CalendarInfo(ctx.app.host, serie.displayName, '', ctx.app.displayName, link, '', serie.lastModified);
};

/**
 * Internal function that retrieves events for a serie. This function
 * assumes that any validation has happened at an earlier stage.
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to retrieve the events for
 * @param  {Number}         limit               The number of events that should be retrieved
 * @param  {Number}         offset              The number to start paging from
 * @param  {Boolean}        [upcoming]          Whether to only include upcoming events. Defaults to `false`
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Serie}          callback.serie      The serie the events belong to
 * @param  {Event[]}        callback.events     The events for a series
 * @api private
 */
var _getSeriesEvents = function(ctx, id, start, end, limit, offset, upcoming, callback) {
    // Ensure the serie exists
    getSerie(ctx, id, function(err, serie) {
        if (err) {
            return callback(err);
        } else if (serie.AppId !== ctx.app.id && (!ctx.user || !ctx.user.isGlobalAdmin())) {
            return callback({'code': 401, 'msg': 'The events for this serie cannot be retrieved on this application'});
        }

        // Get the events in this serie
        SeriesDAO.getSeriesEvents(serie, start, end, limit, offset, upcoming, function(err, events) {
            if (err) {
                return callback(err);
            }

            return callback(null, serie, events);
        });
    });
};


///////////////////
// Subscriptions //
///////////////////

/**
 * Subscribe a user to an event series
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to subscribe the user to
 * @param  {Number}         [userId]            The id of the user that should be subscribed. Defaults to the current user
 * @param  {Number}         [context]           The id of the organisational unit that the serie belonged to when the user subscribed to it
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var subscribeSeries = module.exports.subscribeSeries = function(ctx, id, userId, context, callback) {
    // Default to the current user if no user was specified
    if (!userId && ctx.user) {
        userId = ctx.user.id;
    }

    // Ensure that the serie and user id are valid numbers
    id = GrasshopperUtil.getNumberParam(id);
    userId = GrasshopperUtil.getNumberParam(userId);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can subscribe to a serie'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    validator.check(userId, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    if (context) {
        context = GrasshopperUtil.getNumberParam(context);
        validator.check(context, {'code': 400, 'msg': 'A valid context organisational unit id must be provided'}).isInt();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the user exists
    UsersAPI.getUser(userId, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Ensure the serie exists
        getSerie(ctx, id, function(err, serie) {
            if (err) {
                return callback(err);
            }

            // Ensure the user and serie are on the same application
            if (user.AppId !== serie.AppId) {
                return callback({'code': 401, 'msg': 'The serie must be on the same application as the user'});
            }

            // Ensure the context exists, if any
            _validateOptionalContext(ctx, context, serie, function(err, orgUnit) {
                if (err) {
                    return callback(err);
                }

                // Ensure the current user can subscribe the specified user to the serie
                SeriesAuthz.canSubscribeSerie(ctx, serie, user, function(err, canSubscribe) {
                    if (err) {
                        return callback(err);
                    } else if (!canSubscribe) {
                        log().warn({'id': serie.id}, 'Unauthorized attempt at subscribing a user to a serie');
                        return callback({'code': 401, 'msg': 'You are not allowed to subscribe a user to a serie'});
                    }

                    UsersDAO.subscribeSeries([serie], user, context, callback);
                });
            });
        });
    });
};

/**
 * Unsubscribe a user from an event series
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to unsubscribe the user from
 * @param  {Number}         [userId]            The id of the user that should be unsubscribed. Defaults to the current user
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var unsubscribeSeries = module.exports.unsubscribeSeries = function(ctx, id, userId, callback) {
    // Default to the current user if no user was specified
    if (!userId && ctx.user) {
        userId = ctx.user.id;
    }

    // Ensure that the serie and user id are valid numbers
    id = GrasshopperUtil.getNumberParam(id);
    userId = GrasshopperUtil.getNumberParam(userId);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can unsubscribe from a serie'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    validator.check(userId, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the user exists
    UsersAPI.getUser(userId, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Ensure the serie exists
        getSerie(ctx, id, function(err, serie) {
            if (err) {
                return callback(err);
            }

            // Ensure the current user can unsubscribe the specified user from the serie
            SeriesAuthz.canUnsubscribeSerie(ctx, serie, user, function(err, canUnsubscribe) {
                if (err) {
                    return callback(err);
                } else if (!canUnsubscribe) {
                    log().warn({'id': serie.id}, 'Unauthorized attempt at unsubscribing a user from a serie');
                    return callback({'code': 401, 'msg': 'You are not allowed to unsubscribe user from a serie'});
                }

                UsersDAO.unsubscribeSeries([serie], user, callback);
            });
        });
    });
};

/**
 * Validate a context (organisational unit) that is used when subscribing to a serie. This
 * function will check whether the organisational unit exists and whether the serie belongs
 * to the organisational unit.
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         [orgUnitId]         The id of the organisational unit to retrieve
 * @param  {Serie}          serie               The serie that should belong to the organisational unit
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {OrgUnit}        callback.orgUnit    The retrieved organisational unit or null, if no `orgUnitId` was specified
 */
var _validateOptionalContext = function(ctx, orgUnitId, serie, callback) {
    if (!orgUnitId) {
        return callback();
    }

    // Ensure the organisational unit exists. Also include the series
    // under this organisational unit so we can verify whether the current
    // serie is part of this organisational unit
    OrgUnitDAO.getOrgUnit(orgUnitId, true, function(err, orgUnit) {
        if (err) {
            return callback(err);

        // Ensure the serie is under the organisational unit
        } else if (!_.find(orgUnit.Series, {'id': serie.id})) {
            return callback({'code': 400, 'msg': 'The serie is not under the organisational unit'});
        }

        return callback(null, orgUnit);
    });
};
