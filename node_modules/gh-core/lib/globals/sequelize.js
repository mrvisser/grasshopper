/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var Promise = require('sequelize/lib/promise');

/*!
 * If an unhandled rejection / error occurs, promote the exception to the express middleware
 * handler (i.e., HTTP 500 error). This is necessary to handle the case where the error is thrown
 * from the `catch` promise condition when an error is thrown from the callback
 */
Promise.onPossiblyUnhandledRejection(function(err) {
    throw err;
});

/**
 * Add a style helper to the sequelize Promise that allows us to use callback-style error handling
 *
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {Args}       callback.arg0   A variable number of callback-specific return arguments
 */
Promise.prototype.complete = function(callback) {
    // Tracks whether or not a result has been sent to the callback to ensure we don't invoke it
    // twice
    var _done = false;

    this

        // If the DB query succeeds, this `then` is invoked with the result(s) starting from the
        // first parameter
        .then(function() {
            if (!_done) {
                // Indicate that we have invoked the callback. If the code inside the callback
                // throws an exception, it will go through *this* promise's `catch` handler! So
                // we need to make sure if that happens we have recorded the fact that the
                // callback was entered once
                _done = true;

                // Shift a null value as the first parameter in the callback to indicate the
                // result is a success
                var args = Array.prototype.slice.call(arguments);
                args.unshift(null);
                callback.apply(null, args);
            }
        })

        // If an error occurs during the DB query, *OR* in the callback, this catch is invoked
        .catch(function(err) {
            if (!_done) {
                // The `then` handler was not invoked, which means the error occurred in the DB
                // query. We will invoke the callback with the error
                _done = true;
                callback.call(null, err);
            } else {
                // The `then` handler was already invoked, which means the error occurred in the
                // callback. Promote the exception as it would under normal callback circumstances
                throw err;
            }
        });
};
