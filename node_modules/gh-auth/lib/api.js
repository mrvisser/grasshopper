/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var crypto = require('crypto');
var passport = require('passport');
var LocalStrategy = require('passport-local').Strategy;

var AdminsAPI = require('gh-admins');
var AdminsDAO = require('gh-admins/lib/internal/dao');
var ConfigAPI = require('gh-config');
var Context = require('gh-context').Context;
var GrassHopper = require('gh-core');
var log = require('gh-core/lib/logger').logger('gh-apps');
var UsersAPI = require('gh-users');
var UsersDAO = require('gh-users/lib/internal/dao');
var Validator = require('gh-core/lib/validator').Validator;

var ShibbolethStrategy = require('./shibboleth/strategy');

/**
 * Initialise the authentication module
 *
 * @param  {Object}         config              The application configuration
 */
var initialise = module.exports.initialise = function(config) {
    // Register the Passport authentication strategies
    registerLocalAuthentication();
    registerShibbolethAuthentication();

    // Register the Passport serializers
    registerSerializeUser(config.cookie.secret);
    registerDeserializeUser(config.cookie.secret);

    // Add the context middleware to the global admin and app Express servers
    // This needs to happen *AFTER* all authentication strategies have been initialized
    GrassHopper.appServer.use(contextMiddleware);
    GrassHopper.globalAdminServer.use(contextMiddleware);
};

/**
 * Register the Passport local authentication strategy
 *
 * @api private
 */
var registerLocalAuthentication = function() {
    passport.use(new LocalStrategy({'passReqToCallback': true}, function(req, username, password, done) {
        // The user is logging in as a global administrator
        if (req.ghApp.isGlobalAdmin) {
            AdminsAPI.validateLoginCredentials(username, password, function(err, globalAdmin) {
                // The provided global administrator credentials are incorrect
                if (err && err.code === 401) {
                    return done(null, false);
                // A different error occured
                } else if (err) {
                    return done(err);
                }

                log().info({'globalAdmin': globalAdmin}, 'Logged in as a global administrator');
                var authInfo = {'user': globalAdmin, 'app': req.ghApp};
                return done(null, authInfo);
            });

        // The user is logging in on a regular app
        } else {
            UsersAPI.validateLoginCredentials(req.ghApp.id, username, password, function(err, user) {
                // The provided user credentials are incorrect
                if (err && err.code === 401) {
                    return done(null, false);
                // A different error occured
                } else if (err) {
                    return done(err);
                }

                log().info({'user': user}, 'Logged in as a user with a local authentication strategy');
                var authInfo = {'user': user, 'app': req.ghApp};
                return done(null, authInfo);
            });
        }
    }));
};

/**
 * Register the Passport Shibboleth authentication strategy
 *
 * @api private
 */
var registerShibbolethAuthentication = function() {
    passport.use(new ShibbolethStrategy(function(req, app, headers, callback) {

        log().debug({
            'app': app,
            'headers': headers
        }, 'Received Shibboleth authentication callback');

        var config = ConfigAPI.config(app.id);
        var shibExternalIdAttributes = config.shibExternalIdAttributes;
        var shibMapDisplayname = config.shibMapDisplayname;
        var shibMapEmail = config.shibMapEmail;

        // The external ID is configurable in the admin UI as a priority list (similar to
        // how `mod_shib` works). We try to find an attribute in the released set that matches
        // any of the configurable attributes. Rather than relying on `mod_shib`'s `remote_user`
        // attribute, we rely on the configured list as it allows administrators to specify
        // attributes on a per-tenant basis. We use `remote_user` as the fall back value
        var externalId = _getBestAttributeValue(app, shibExternalIdAttributes, headers, headers['remote_user']);
        if (!externalId) {
            log().error({'headers': headers, 'app': app}, 'No suitable attribute was found for the `externalId` attribute');
            return callback({'code': 500, 'msg': 'No suitable attribute was found for the `externalId` attribute'});
        }

        // There are a lot of SAML attributes that may indicate a user's display name. The administrator
        // should provide a suitable priority list to construct the displayName. If no suitable value was
        // returned from the mapping, we fall back to the `remote_user` attribute, as this is always provided
        var displayName = _getBestAttributeValue(app, shibMapDisplayname, headers, headers['remote_user']);

        // Set the optional profile parameters
        var opts = {};

        // Get an email address from the provided headers. We fall back to `eppn` which may not always
        // contain a valid email address. We only set the `email` value if a valid email has been provided
        var email = _getBestAttributeValue(app, shibMapEmail, headers, headers['eppn']);
        if (email) {
            var validator = new Validator();
            validator.check(email, {'code': 400, 'msg': 'Invalid email'}).isEmail();
            if (!validator.hasErrors()) {
                opts['email'] = email;
            } else {
                log().warn({'email': email, 'externalId': externalId, 'tenant': tenant.alias}, 'A user signed in via Shib with an invalid email address');
            }
        }

        // Check if the user already exists
        UsersAPI.getUserByCredentials(app.id, 'shibboleth', externalId, function(err, user) {
            log().info(arguments);
            if (err && err.code !== 404) {
                return callback(err);
            } else if (user) {
                log().debug({'user': user.id, 'externalId': externalId}, 'User logged in via Shibboleth');
                return callback(null, user);
            }

            // The user was not found, create a record
            log().debug({
                'externalId': externalId,
                'displayName': displayName,
                'email': email
            }, 'New user logged in via shibboleth, creating new account');
            var userProfile = {
                'displayName': displayName,
                'email': email,
                'emailPreference': 'immediate',
                'isAdmin': false
            };
            var credentials = {
                'strategy': 'shibboleth',
                'shibbolethId': externalId
            };
            return UsersDAO.createUser(app.id, userProfile, credentials, callback);
        });
    }));
};

/**
 * Get the value from the attribute that best matches a configured priority list
 *
 * @param  {App}        app                 The app for which to retrieve the priority list
 * @param  {String}     priorityList        A prioritised space seperated list
 * @param  {Object}     headers             The headers that were passed along by mod_shib
 * @param  {String}     [defaultValue]      A default value that can be fallen back to
 * @return {String}                         The value of the attribute that best matched the configured priority list
 * @api private
 */
var _getBestAttributeValue = function(app, priorityList, headers, defaultValue) {
    priorityList = _.chain(priorityList.split(' '))
        .compact()
        .uniq()
        .value();

    var attribute = _.find(priorityList, function(attribute) {
        return (headers[attribute] && headers[attribute] !== defaultValue);
    });

    var value = headers[attribute] || defaultValue;
    return value;
};


/**
 * Express middleware that will add the Grasshopper `Context` to each request at `req.ctx`.
 * This context object will contain the current app, the currently authenticated user and
 * the user impostering the authenticated user
 *
 * @param  {Request}    req     The Express.js request
 * @param  {Response}   res     The express.js response
 * @param  {Function}   next    Standard callback function
 * @api private
 */
var contextMiddleware = function(req, res, next) {
    var user = null;
    if (req.authInfo && req.authInfo.user) {
        user = req.authInfo.user;
    }

    // TODO: Add imposter

    req.ctx = new Context(req.ghApp, user);
    return next();
};

/**
 * Register the Passport serialize user function. This determines
 * what is stored in the session cookie
 *
 * @param  {String}         cookieSecret        The cookie secret to encrypt the session cookie with
 * @api private
 */
var registerSerializeUser = function(cookieSecret) {
    passport.serializeUser(function(authInfo, callback) {
        // Serialize the user id and whether the user is logged in
        // on the global admin server to the session cookie
        var sessionCookie = {
            'userId': authInfo.user.id,
            'isGlobalAdmin': authInfo.app.isGlobalAdmin
        };

        var encryptedCookie = _encryptCookieData(JSON.stringify(sessionCookie), cookieSecret);
        return callback(null, encryptedCookie);
    });
};

/**
 * Register the Passport deserialize user function. This retrieves
 * the currently logged in user based on the session cookie data.
 *
 * @param  {String}         cookieSecret        The cookie secret used to encrypt the session cookie
 * @api private
 */
var registerDeserializeUser = function(cookieSecret) {
    passport.deserializeUser(function(encryptedCookie, callback) {
        var sessionData = _decryptCookieData(encryptedCookie, cookieSecret);

        try {
            // Parse the cookie data
            sessionData = JSON.parse(sessionData);
        } catch (err) {
            // If parsing failed, the user cookie has malformed session data or has been tampered with.
            // Continue with an empty session
            log().error({'err': err, 'sessionData': sessionData}, 'Failed to deserialize the user cookie');
            sessionData = {};
        }

        // If there is no user in the session, fall back to an anonymous session
        if (!sessionData.userId) {
            return callback(null, false);
        }

        // The user is logged in as a global administrator
        if (sessionData.isGlobalAdmin) {
            AdminsDAO.getGlobalAdmin(sessionData.userId, function(err, globalAdmin) {
                if (err) {
                    log().error({'err': err, 'sessionData': sessionData}, 'Failed to retrieve the global administrator from the session cookie');
                    return callback(err);
                }

                return callback(null, {'user': globalAdmin, 'isGlobalAdmin': sessionData.isGlobalAdmin});
            });

        // The user is logged in on a regular app
        } else {
            UsersAPI.getUser(sessionData.userId, function(err, user) {
                if (err) {
                    log().error({'err': err, 'sessionData': sessionData}, 'Failed to retrieve the logged in user from the session cookie');
                    return callback(err);
                }

                return callback(null, {'user': user, 'isGlobalAdmin': sessionData.isGlobalAdmin});
            });
        }
    });
};

/**
 * Encrypt cookie data to send to the client
 *
 * @param  {String}     cookieData      The cookie data to encrypt
 * @param  {String}     cookieSecret    The secret to encrypt the cookie data with
 * @return {String}                     The encrypted cookie data
 * @api private
 */
var _encryptCookieData = function(cookieData, cookieSecret) {
    var cipher = crypto.createCipher('aes-256-cbc', cookieSecret);
    return cipher.update(cookieData, 'utf8', 'base64') + cipher.final('base64');
};

/**
 * Decrypt cookie data provided by the client
 *
 * @param  {String}     encryptedData   The encrypted cookie data to decrypt
 * @param  {String}     cookieSecret    The secret to decrypt the data with
 * @return {String}                     The decrypted cookie data
 * @api private
 */
var _decryptCookieData = function(encryptedData, cookieSecret) {
    var decipher = crypto.createDecipher('aes-256-cbc', cookieSecret);
    return decipher.update(encryptedData, 'base64', 'utf8') + decipher.final('utf8');
};
